"""
Массив размером 2m + 1, где m — натуральное число, заполнен случайным образом.
Найдите в массиве медиану. Медианой называется элемент ряда, делящий его на две равные части:
в одной находятся элементы, которые не меньше медианы, в другой — не больше медианы.

Примечание: задачу можно решить без сортировки исходного массива. Но если это слишком сложно,
используйте метод сортировки, который не рассматривался на уроках (сортировка слиянием также недопустима)
"""
import random
import statistics

SIZE = 11
MIN_ITEM = 0
MAX_ITEM = 100
data = [random.randint(MIN_ITEM, MAX_ITEM) for _ in range(SIZE)]
print(data)

m = int((SIZE - 1) / 2)

#Пытался придумать без сортировки. По факту не работает
##################################
avg = sum(data) / SIZE
g_mean = statistics.geometric_mean(data)


# a = 0
# b = 0
#
# for j in range(len(data) - 1):
#     if data[j] < data[j+1]:
#         a += 1
#     else:
#         b += 1
#
# print(f"{a = }")
# print(f"{b = }")
# mediana = data[a]

#########################################


#Другой код, который не использовался (честно найденный Timsort)
def insertion_sort(array, left=0, right=None):
    if right is None:
        right = len(array) - 1
    # Цикл от элемента, обозначенного
    # `left` до элемента, обозначенного` right`
    for i in range(left + 1, right + 1):
        # Это элемент, который мы хотим разместить в
        # правильное место
        key_item = array[i]
       # Инициализировать переменную, которая будет использоваться для
        # найти правильную позицию указанного элемента
        # by `key_item`
        j = i - 1
        # Просмотрите список элементов (слева
        # часть массива) и найдите правильную позицию
        # элемента, на который ссылается `key_item`. Сделай это только
        # если `key_item` меньше, чем соседние значения.
        while j >= left and array[j] > key_item:
            # Сдвинуть значение на одну позицию влево
            # и переместите `j`, чтобы указать на следующий элемент
            # (справа налево)
            array[j + 1] = array[j]
            j -= 1
        # Когда вы закончите сдвигать элементы, установите
        # `key_item` в правильном месте
        array[j + 1] = key_item
    return array

def timsort(array):
    min_run = 32
    n = len(array)
    # Начните с нарезки и сортировки небольших порций
    # входной массив. Размер этих срезов определяется
    # размер вашего `min_run`.
    for i in range(0, n, min_run):
        insertion_sort(array, i, min((i + min_run - 1), n - 1))
    # Теперь вы можете начать объединение отсортированных фрагментов.
    # Начать с min_run, увеличивая размер вдвое
    # каждую итерацию, пока вы не превысите длину
    # массив.
    size = min_run
    while size < n:
        # Определить массивы, которые будут
        # быть объединенными
        for start in range(0, n, size * 2):
            # Вычислить среднюю точку (где заканчивается первый массив
            # и второй запуск) и ʻendpoint` (где
            # второй массив заканчивается)
            midpoint = start + size - 1
            end = min((start + size * 2 - 1), (n-1))
            # Объединить два подмассива.
            # Массив `left` должен идти от` start` до
            # `midpoint + 1`, а массив` right` должен
            # перейти от `midpoint + 1` к ʻend + 1`.
            merged_array = merge(
                left=array[start:midpoint + 1],
                right=array[midpoint + 1:end + 1])
            # Наконец, поместите объединенный массив обратно в
            # ваш массив
            array[start:start + len(merged_array)] = merged_array
        # Каждая итерация должна удваивать размер ваших массивов
        size *= 2
    return array

timsort(data)
print(data)
print("Медиана = ", data[m])
print("Среднее арифметическе = ", avg)
print("Среднее геометрическое =", g_mean)
#print("Медиана без сортировки = ", mediana)
print("Медиана statistics = ", statistics.median(data)) #самый простой вариант